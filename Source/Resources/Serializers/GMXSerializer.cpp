/**
 *  @file GMXSerializer.cpp
 *	@section License
 *
 *      Copyright (C) 2013 Daniel Hrabovcak
 *
 *      This file is a part of the Natural GM IDE. MIT License.
 *
 *      Permission is hereby granted, free of charge, to any person obtaining a copy
 *		of this software and associated documentation files (the "Software"), to deal
 *		in the Software without restriction, including without limitation the rights
 *		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *		copies of the Software, and to permit persons to whom the Software is
 *		furnished to do so, subject to the following conditions:
 *
 *		The above copyright notice and this permission notice shall be included in
 *		all copies or substantial portions of the Software.
 *
 *		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *		THE SOFTWARE.
**/
#include "GMXSerializer.hpp"
#include "String.hpp"
#include "Set.hpp"
#include "Map.hpp"
#include <QDebug>
#include <QFile>

namespace NGM
{
	namespace Resource
	{
		using namespace rapidxml;

		GMXSerializer::GMXSerializer() : Serializer() {}

		void GMXSerializer::read(Editor *editor, Resource *resource, const SerializerOptions &options) const
		{

		}

		void GMXSerializer::write(Editor *editor, Resource *resource, const SerializerOptions &options) const
		{

		}

		bool GMXSerializer::save(Model::ResourceProjectItem *item, QProgressBar *progressBar) const
		{
			xml_document<> document;
			xml_attribute<> *attribute;
			xml_node<> *node, *childNode, *rootNode = document.allocate_node(node_comment, 0, "This Document "
			"was generated by Natural GM, if you edit it by hand then you do so at your own risk!");
			document.append_node(rootNode);
			rootNode = document.allocate_node(node_element, "assets");
			document.append_node(rootNode);
			attribute = document.allocate_attribute("hash", item->resource->serialData->attributes["hash"].c_str(), 4);
			rootNode->append_attribute(attribute);

			QString name;
			for (int i = 0; i < item->count(); ++i)
			{
				if (item->child(i)->toGroupItem())
				{
					name = item->child(i)->name();
					if (name.size() == 7)
					{
						if (name == "Sprites")
						{
							node = document.allocate_node(node_element, "sprites");
							node->append_node(rootNode);
							createTree("sprite", "sprites", &document, item->child(i)->toGroupItem(), node);
						}
						else if (name == "Objects")
						{
							node = document.allocate_node(node_element, "objects");
							node->append_node(rootNode);
							createTree("object", "objects", &document, item->child(i)->toGroupItem(), node);
						}
						else if (name == "Scripts")
						{
							node = document.allocate_node(node_element, "scripts");
							node->append_node(rootNode);
							createTree("script", "scripts", &document, item->child(i)->toGroupItem(), node);
						}
						else if (name == "Shaders")
						{
							node = document.allocate_node(node_element, "shaders");
							node->append_node(rootNode);
							createTree("shader", "shaders", &document, item->child(i)->toGroupItem(), node);
						}
					}
					else if (name.size() == 4)
					{
						if (name == "Paths")
						{
							node = document.allocate_node(node_element, "paths");
							node->append_node(rootNode);
							createTree("path", "paths", &document, item->child(i)->toGroupItem(), node);
						}
						else if (name == "Fonts")
						{
							node = document.allocate_node(node_element, "fonts");
							node->append_node(rootNode);
							createTree("font", "fonts", &document, item->child(i)->toGroupItem(), node);
						}
					}
					else if (name.size() == 6)
					{
						if (name == "Sounds")
						{
							node = document.allocate_node(node_element, "sounds");
							node->append_node(rootNode);
							createTree("sound", "sounds", &document, item->child(i)->toGroupItem(), node);
						}
					}
					else if (name == "Timelines")
					{
						node = document.allocate_node(node_element, "timelines");
						node->append_node(rootNode);
						createTree("timeline", "timelines", &document, item->child(i)->toGroupItem(), node);
					}
					else if (name == "Backgrounds")
					{
						node = document.allocate_node(node_element, "backgrounds");
						node->append_node(rootNode);
						createTree("background", "backgrounds", &document, item->child(i)->toGroupItem(), node);
					}
					else if (name == "Rooms")
					{
						node = document.allocate_node(node_element, "rooms");
						node->append_node(rootNode);
						createTree("room", "rooms", &document, item->child(i)->toGroupItem(), node);
					}
					else
					{
						qWarning() << "GMX Serializer: save: Unknown group:" << name;
						return false;
					}
				}
			}

			node = document.allocate_node(node_element, "constants");
			for (auto &i : item->resource->serialData->children["constants"]->asObject()->attributes)
			{
				childNode = document.allocate_node(node_element, "constant", i.second.c_str());
				attribute = document.allocate_attribute("name", i.first.c_str());
				childNode->append_attribute(attribute);
				node->append_node(childNode);
			}
			rootNode->append_node(node);
		}

		bool GMXSerializer::structure(Model::ResourceProjectItem *item, QProgressBar *progressBar) const
		{
			xml_document<> document;
			QFile file(item->resource->location);
			file.open(QFile::ReadOnly);
			QByteArray data = file.readAll();
			document.parse<0>(&data.data()[0]);

			xml_node<> *node, *rootNode = document.first_node("assets");
			xml_attribute<> *attr = rootNode->first_attribute();

			SerialObject *projectData = new SerialObject;
			item->resource->serialData = projectData;

			while(attr != nullptr)
			{
				if (strncmp("hash", attr->name(), 4) != 0)
				{
					qWarning() << "GMX Serializer: assets: Unknown attribute found.";
					return false;
				}
				projectData->attributes["hash"] = attr->value();
				attr = attr->next_attribute();
			}

			Model::ResourceGroupItem *group[Size];
			group[Sprite] = new Model::ResourceGroupItem("Sprites");
			group[Sound] = new Model::ResourceGroupItem("Sounds");
			group[Background] = new Model::ResourceGroupItem("Backgrounds");
			group[Path] = new Model::ResourceGroupItem("Paths");
			group[Script] = new Model::ResourceGroupItem("Scripts");
			group[Shader] = new Model::ResourceGroupItem("Shaders");
			group[Font] = new Model::ResourceGroupItem("Fonts");
			group[Timeline] = new Model::ResourceGroupItem("Timelines");
			group[Object] = new Model::ResourceGroupItem("Objects");
			group[Room] = new Model::ResourceGroupItem("Rooms");
			group[Datafile] = new Model::ResourceGroupItem("Datafiles");
			group[Extension] = new Model::ResourceGroupItem("Extensions");
			group[Constant] = new Model::ResourceGroupItem("Constants");

			Resource * infoResource = new Resource(0, 0, 0);
			Model::ResourceContentItem *infoItem = new Model::ResourceContentItem(infoResource, "Information");

			item->append(group[Sprite]);
			item->append(group[Sound]);
			item->append(group[Background]);
			item->append(group[Path]);
			item->append(group[Script]);
			item->append(group[Shader]);
			item->append(group[Font]);
			item->append(group[Timeline]);
			item->append(group[Object]);
			item->append(group[Room]);
			item->append(group[Datafile]);
			item->append(group[Extension]);
			item->append(group[Constant]);
			item->append(infoItem);

			Resource * constantsResource = new Resource(0, 0, 0);
			Model::ResourceContentItem *constantsItem = new Model::ResourceContentItem(constantsResource, "Default");
			SerialObject *constantsData = new SerialObject;
			constantsResource->serialData = constantsData;
			group[Constant]->append(constantsItem);

			Map<String, Resource*> spriteMap, backgroundMap, objectMap, roomMap;

			int count = 0;
			for (node = rootNode->first_node(); node != NULL; node = node->next_sibling())
			{
				++count;
			}
			progressBar->setMaximum(count+1);

			for (node = rootNode->first_node(); node != NULL; node = node->next_sibling())
			{
				if (node->name_size() == 7)
				{
					if (strncmp("Configs", node->name(), 7) == 0)
					{

					}
					else if (strncmp("sprites", node->name(), 7) == 0)
					{
						Queue<Type*> q;
						addSprite(group[Sprite], node, q);
					}
					else if (strncmp("scripts", node->name(), 7) == 0)
					{
						addScript(group[Script], node);
					}
					else if (strncmp("shaders", node->name(), 7) == 0)
					{
						addShader(group[Shader], node);
					}
					else if (strncmp("objects", node->name(), 9) == 0)
					{
						addObject(group[Object], node);
					}
				}
				else if (node->name_size() == 9)
				{
					if (strncmp("datafiles", node->name(), 9) == 0)
					{
						addDatafile(group[Datafile], node);
					}
					else if (strncmp("timelines", node->name(), 9) == 0)
					{
						addTimeline(group[Timeline], node);
					}
					else if (strncmp("constants", node->name(), 9) == 0)
					{
						for (xml_node<> *i = node->first_node(); i; i = i->next_sibling())
						{
							if (strncmp("constant", i->name(), 8) == 0 && i->name_size() == 8)
							{
								for (xml_attribute<> *n = i->first_attribute(); n; n = n->next_attribute())
								{
									if (strncmp("name", n->name(), 4) == 0 && n->name_size() == 4)
									{
										constantsData->attributes[n->value()] = i->value();
									}
									else
									{
										qWarning() << "GMX Serializer: Unknown constant attribute:" << n->name();
										return 0;
									}
								}
							}
							else
							{
								qWarning() << "GMX Serializer: Unknown constant type:" << i->name();
								return 0;
							}
						}
					}
				}
				else if (node->name_size() == 5)
				{
					if (strncmp("paths", node->name(), 5) == 0)
					{
						addPath(group[Path], node);
					}
					else if (strncmp("fonts", node->name(), 5) == 0)
					{
						addFont(group[Font], node);
					}
					else if (strncmp("rooms", node->name(), 5) == 0)
					{
						addRoom(group[Room], node);
					}
				}
				else if (node->name_size() == 13 && strncmp("NewExtensions", node->name(), 13) == 0)
				{
					addExtension(group[Extension], node);
				}
				else if (node->name_size() == 6 && strncmp("sounds", node->name(), 6) == 0)
				{
					addSound(group[Sound], node);
				}
				else if (node->name_size() == 11 && strncmp("backgrounds", node->name(), 11) == 0)
				{
					addBackground(group[Background], node);
				}
				else if (node->name_size() == 4 && strncmp("help", node->name(), 4) == 0)
				{
					count = 0;
					xml_node<> *i;
					for (i = node->first_node(); i; i = i->next_sibling())
					{
						++count;
					}
					if (count > 1)
					{
						qWarning() << "GMX Serializer: Too many help files.";
						return 0;
					}
					i = node->first_node();
					if (strncmp("rtf", i->name(), 3) == 0 && i->name_size() == 3)
					{
						infoResource->location = item->directory()+i->value();
					}
				}
				else if (node->name_size() == 13 && strncmp("TutorialState", node->name(), 13) == 0)
				{
					for (xml_node<> *i = node->first_node(); i; i = i->next_sibling())
					{
						if (strncmp("IsTutorial", i->name(), 10) == 0 && i->name_size() == 10)
						{
							projectData->attributes["tutorial"] = i->value();
						}
						else if (strncmp("TutorialName", i->name(), 12) == 0 && i->name_size() == 12)
						{
							projectData->attributes["tutorial_name"] = i->value();
						}
						else if (strncmp("TutorialPage", i->name(), 12) == 0 && i->name_size() == 12)
						{
							projectData->attributes["tutorial_index"] = i->value();
						}
						else
						{
							qWarning() << "GMX Serializer: Unknown tutorial type:" << i->name();
							return 0;
						}
					}
				}
				else
				{
					qWarning() << "GMX Serializer: assets: Unknown child: " << node->name();
					return false;
				}
				progressBar->setValue(progressBar->value()+1);
			}
			file.close();

			String cacheName;
			Set<String> cached;
			QString directory = item->directory();
			for (Pair<String, Resource*> i : roomMap)
			{
				SerialResource *serialResource = new SerialResource;
				i.second->serialData->children["object_cache"] = serialResource;
				i.second->serialData->children["background_cache"] = serialResource;

				if (~item->settings & IsPreloaded)
				{
					QFile room(directory+i.second->location);
					room.open(QFile::ReadOnly);
					data = room.readAll();
					document.parse<0>(&data.data()[0]);

					rootNode = document.first_node("room");

					for (node = rootNode->first_node("background")->first_node(); node; node = node->next_sibling())
					{
						if (strncmp("background", node->name(), 10) && node->name_size() == 10)
						{
							attr = node->first_attribute("name");
							if (attr->value_size() != 0)
							{
								cacheName = String(attr->value(), attr->value_size());
								if (cached.find(cacheName) == cached.end())
								{
									serialResource->resources.push_back( backgroundMap.find(cacheName)->second);
									cached.insert(cacheName);
								}
							}
						}
					}
				}
				cached.clear();
			}

			return true;
		}

		void GMXSerializer::restructure(Model::ResourceProjectItem *item) const
		{

		}

		void GMXSerializer::addSprite(Model::ResourceGroupItem *item, xml_node<> *node,
			const Queue<Type*> &type, const SerializerOptions &options) const
		{
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("sprite", node->name(), 6) == 0)
				{
					if (node->name()[6] != 's')
					{
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, QString(&node->value()[8]));
						item->append(content);

						SerialObject *imageData = new SerialObject;
						resource->serialData = imageData;

						QString filepath = content->root()->directory();
						filepath.append(node->value());

						Vector<QPixmap*> *imagesVector = new Vector<QPixmap*>;
						imagesVector->push_back(new QPixmap(filepath));
						SerialVariant *imagesVariant = new SerialVariant();
						imagesVariant->variant.setPixmapVec(imagesVector);

						resource->serialData->children["image"] = imagesVariant;
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: sprite: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: sprite: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: sprite: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addBackground(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("background", node->name(), 10) == 0)
				{
					if (node->name()[10] != 's')
					{
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, QString(&node->value()[11]));
						item->append(content);

						SerialObject *imageData = new SerialObject;
						resource->serialData = imageData;

						QString filepath = content->root()->directory();
						filepath.append(node->value());

						SerialVariant *imagesVariant = new SerialVariant();
						imagesVariant->variant.setPixmap(new QPixmap(filepath));

						resource->serialData->children["image"] = imagesVariant;
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: background: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: background: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: background: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addSound(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("sound", node->name(), 5) == 0)
				{
					if (node->name()[5] != 's')
					{
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, QString(&node->value()[6]));
						item->append(content);
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: sound: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: sound: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: sound: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addPath(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("path", node->name(), 4) == 0)
				{
					if (node->name()[4] != 's')
					{
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, QString(&node->value()[6]));
						item->append(content);
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: path: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: path: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: path: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addScript(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			QString str;
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("script", node->name(), 6) == 0)
				{
					if (node->name()[6] != 's')
					{
						str = QString(&node->value()[8]);
						str.chop(4);
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, str);
						item->append(content);
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: script: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: script: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: script: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addShader(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			QString str;
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("shader", node->name(), 6) == 0)
				{
					if (node->name()[6] != 's')
					{
						str = QString(&node->value()[8]);
						str.chop(7);
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, str);
						item->append(content);
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: shader: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: shader: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: shader: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addTimeline(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("timeline", node->name(), 8) == 0)
				{
					if (node->name()[8] != 's')
					{
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, QString(&node->value()[10]));
						item->append(content);
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: timeline: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: timeline: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: timeline: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addFont(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("font", node->name(), 4) == 0)
				{
					if (node->name()[4] != 's')
					{
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, QString(&node->value()[6]));
						item->append(content);
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: font: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: font: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: font: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addObject(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("object", node->name(), 6) == 0)
				{
					if (node->name()[6] != 's')
					{
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, QString(&node->value()[8]));
						item->append(content);
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: object: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: object: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: object: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addRoom(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("room", node->name(), 4) == 0)
				{
					if (node->name()[4] != 's')
					{
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, QString(&node->value()[6]));
						item->append(content);
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: room: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: room: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: room: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addDatafile(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
		}

		void GMXSerializer::addExtension(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
		}

		void GMXSerializer::createTree(const char *typeName, const char *groupName, xml_document<> *document,
									   Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			String location;
			xml_node<> *group;
			xml_attribute<> *attribute;
			for (int i = 0; i < item->count(); ++i)
			{
				if (item->child(i)->toContentItem() != nullptr)
				{
					if (item->child(i)->toContentItem()->resource->location == 0)
					{
						location = "sprites/";
						location += item->name().toLatin1().data();
					}
					else
					{
						location = item->child(i)->toContentItem()->resource->location.toLatin1().data();
					}
					xml_node<> *resource = document->allocate_node(node_element, typeName, location.c_str());
					node->append_node(resource);
				}
				else
				{
					group = document->allocate_node(node_element, groupName);
					attribute = document->allocate_attribute("name", item->name().toLatin1().data());
					group->append_attribute(attribute);
					node->append_node(group);

					createTree(typeName, groupName, document, item->child(i)->toGroupItem(), group);
				}
			}
		}
	}
}
