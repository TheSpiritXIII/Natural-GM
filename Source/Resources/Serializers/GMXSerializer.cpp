/**
 *  @file GMXSerializer.cpp
 *	@section License
 *
 *      Copyright (C) 2013 Daniel Hrabovcak
 *
 *      This file is a part of the Natural GM IDE. MIT License.
 *
 *      Permission is hereby granted, free of charge, to any person obtaining a copy
 *		of this software and associated documentation files (the "Software"), to deal
 *		in the Software without restriction, including without limitation the rights
 *		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *		copies of the Software, and to permit persons to whom the Software is
 *		furnished to do so, subject to the following conditions:
 *
 *		The above copyright notice and this permission notice shall be included in
 *		all copies or substantial portions of the Software.
 *
 *		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *		THE SOFTWARE.
**/
#include <QLatin1String>
#include <QFileInfo>
#include <QMessageBox>
#include "GMXSerializer.hpp"
#include "ProjectManager.hpp"
#include "Editor.hpp"
#include "String.hpp"
#include "Stack.hpp"
#include "Set.hpp"
#include "Map.hpp"
#include <QDebug>
#include <QFile>
#include <QDir>

namespace NGM
{
	namespace Resource
	{
		using namespace rapidxml;

		GMXSerializer::GMXSerializer() : Serializer(SetWorkingDir) {}

		void GMXSerializer::read(Editor *editor, Resource *resource, const SerializerOptions &options) const
		{
			if (resource->type->name == QStringLiteral("image"))
			{
				SerialData *data = resource->serialData->children["image"];
				if (data && static_cast<SerialVariant*>(data))
				{
					editor->setProperty("image", static_cast<SerialVariant*>(data)->value);
				}
			}
			else if (resource->type->name == QStringLiteral("file"))
			{

			}
		}

		void GMXSerializer::write(Editor *editor, Resource *resource, const SerializerOptions &options) const
		{

		}

		bool GMXSerializer::save(Model::ResourceProjectItem *item, QProgressBar *progressBar) const
		{
			/*xml_document<> document;
			xml_attribute<> *attribute;
			xml_node<> *node, *childNode, *rootNode = document.allocate_node(node_comment, 0, "This Document "
			"was generated by Natural GM, if you edit it by hand then you do so at your own risk!");
			document.append_node(rootNode);
			rootNode = document.allocate_node(node_element, "assets");
			document.append_node(rootNode);
			attribute = document.allocate_attribute("hash", item->resource->serialData->attributes[QLatin1String("hash")].data(), 4);
			rootNode->append_attribute(attribute);

			QString name;
			for (int i = 0; i < item->count(); ++i)
			{
				if (item->child(i)->toGroupItem())
				{
					name = item->child(i)->name();
					if (name.size() == 7)
					{
						if (name == "Sprites")
						{
							node = document.allocate_node(node_element, "sprites");
							node->append_node(rootNode);
							createTree("sprite", "sprites", &document, item->child(i)->toGroupItem(), node);
						}
						else if (name == "Objects")
						{
							node = document.allocate_node(node_element, "objects");
							node->append_node(rootNode);
							createTree("object", "objects", &document, item->child(i)->toGroupItem(), node);
						}
						else if (name == "Scripts")
						{
							node = document.allocate_node(node_element, "scripts");
							node->append_node(rootNode);
							createTree("script", "scripts", &document, item->child(i)->toGroupItem(), node);
						}
						else if (name == "Shaders")
						{
							node = document.allocate_node(node_element, "shaders");
							node->append_node(rootNode);
							createTree("shader", "shaders", &document, item->child(i)->toGroupItem(), node);
						}
					}
					else if (name.size() == 4)
					{
						if (name == "Paths")
						{
							node = document.allocate_node(node_element, "paths");
							node->append_node(rootNode);
							createTree("path", "paths", &document, item->child(i)->toGroupItem(), node);
						}
						else if (name == "Fonts")
						{
							node = document.allocate_node(node_element, "fonts");
							node->append_node(rootNode);
							createTree("font", "fonts", &document, item->child(i)->toGroupItem(), node);
						}
					}
					else if (name.size() == 6)
					{
						if (name == "Sounds")
						{
							node = document.allocate_node(node_element, "sounds");
							node->append_node(rootNode);
							createTree("sound", "sounds", &document, item->child(i)->toGroupItem(), node);
						}
					}
					else if (name == "Timelines")
					{
						node = document.allocate_node(node_element, "timelines");
						node->append_node(rootNode);
						createTree("timeline", "timelines", &document, item->child(i)->toGroupItem(), node);
					}
					else if (name == "Backgrounds")
					{
						node = document.allocate_node(node_element, "backgrounds");
						node->append_node(rootNode);
						createTree("background", "backgrounds", &document, item->child(i)->toGroupItem(), node);
					}
					else if (name == "Rooms")
					{
						node = document.allocate_node(node_element, "rooms");
						node->append_node(rootNode);
						createTree("room", "rooms", &document, item->child(i)->toGroupItem(), node);
					}
					else
					{
						qWarning() << "GMX Serializer: save: Unknown group:" << name;
						return false;
					}
				}
			}

			node = document.allocate_node(node_element, "constants");

			QMap<QLatin1String, QLatin1String> map = static_cast<SerialObject*>(item->resource->serialData->children[QLatin1String("constants")])->attributes;
			QMap<QLatin1String, QLatin1String>::const_iterator i = map.constBegin();
			while (i != map.constEnd())
			{
				childNode = document.allocate_node(node_element, "constant", i.value().data());
				attribute = document.allocate_attribute("name", i.key().data());
				childNode->append_attribute(attribute);
				node->append_node(childNode);
				++i;
			}

			rootNode->append_node(node);*/
		}

		bool GMXSerializer::structure(Model::ResourceProjectItem *item,
			const Manager::ProjectManager *projectManager,
			QProgressBar *progressBar) const
		{
			/*xml_document<> document;
			QFile file(item->resource->location);
			file.open(QFile::ReadOnly);
			QByteArray data = file.readAll();
			document.parse<0>(&data.data()[0]);

			QDir::setCurrent(item->directory());

			xml_node<> *node, *rootNode = document.first_node("assets");
			xml_attribute<> *attr = rootNode->first_attribute();

			SerialObject *projectData = new SerialObject;
			item->resource->serialData = projectData;

			while(attr != nullptr)
			{
				if (strncmp("hash", attr->name(), 4) != 0)
				{
					qWarning() << "GMX Serializer: assets: Unknown attribute found.";
					return false;
				}
				projectData->attributes[QLatin1String("hash")] = QLatin1String(attr->value());
				attr = attr->next_attribute();
			}

			Model::ResourceGroupItem *group[Size];
			group[Sprite] = new Model::ResourceGroupItem("Sprites");
			group[Sound] = new Model::ResourceGroupItem("Sounds");
			group[Background] = new Model::ResourceGroupItem("Backgrounds");
			group[Path] = new Model::ResourceGroupItem("Paths");
			group[Script] = new Model::ResourceGroupItem("Scripts");
			group[Shader] = new Model::ResourceGroupItem("Shaders");
			group[Font] = new Model::ResourceGroupItem("Fonts");
			group[Timeline] = new Model::ResourceGroupItem("Timelines");
			group[Object] = new Model::ResourceGroupItem("Objects");
			group[Room] = new Model::ResourceGroupItem("Rooms");
			group[Datafile] = new Model::ResourceGroupItem("Datafiles");
			group[Extension] = new Model::ResourceGroupItem("Extensions");
			group[Constant] = new Model::ResourceGroupItem("Constants");

			Resource * infoResource = new Resource(0, 0, 0);
			Model::ResourceContentItem *infoItem = new Model::ResourceContentItem(infoResource, "Information");

			item->append(group[Sprite]);
			item->append(group[Sound]);
			item->append(group[Background]);
			item->append(group[Path]);
			item->append(group[Script]);
			item->append(group[Shader]);
			item->append(group[Font]);
			item->append(group[Timeline]);
			item->append(group[Object]);
			item->append(group[Room]);
			item->append(group[Datafile]);
			item->append(group[Extension]);
			item->append(group[Constant]);
			item->append(infoItem);

			Resource * constantsResource = new Resource(0, 0, 0);
			Model::ResourceContentItem *constantsItem = new Model::ResourceContentItem(constantsResource, "Default");
			SerialObject *constantsData = new SerialObject;
			constantsResource->serialData = constantsData;
			group[Constant]->append(constantsItem);

			Map<String, Resource*> spriteMap, backgroundMap, objectMap, roomMap, pathMap;

			int count = 0;
			for (node = rootNode->first_node(); node != NULL; node = node->next_sibling())
			{
				++count;
			}
			progressBar->setMaximum(count+1);

			for (node = rootNode->first_node(); node != NULL; node = node->next_sibling())
			{
				if (node->name_size() == 7)
				{
					if (strncmp("Configs", node->name(), 7) == 0)
					{

					}
					else if (strncmp("sprites", node->name(), 7) == 0)
					{
						addResourceM(group[Sprite], node, projectManager->getType("image"),
									 "sprite", sizeof("sprite")-1, QStringLiteral(".sprite.gmx"),
									 spriteMap);
						//addSprite(group[Sprite], node, projectManager->getType("image"), item->resource->location.left(item->resource->location.lastIndexOf('/')));
					}
					else if (strncmp("scripts", node->name(), 7) == 0)
					{
						addResource(group[Script], node, projectManager->getType("file"),
									"script", 0);
					}
					else if (strncmp("shaders", node->name(), 7) == 0)
					{
						addResource(group[Shader], node, projectManager->getType("file"),
									"shader", 0);
					}
					else if (strncmp("objects", node->name(), 9) == 0)
					{
						addResource(group[Object], node, projectManager->getType("gmobject"),
									"object", QStringLiteral(".object.gmx"));
					}
				}
				else if (node->name_size() == 9)
				{
					if (strncmp("datafiles", node->name(), 9) == 0)
					{
						addDatafile(group[Datafile], node);
					}
					else if (strncmp("timelines", node->name(), 9) == 0)
					{
						addResource(group[Timeline], node, projectManager->getType("timeline"),
									"timeline", QStringLiteral(".timeline.gmx"));
					}
					else if (strncmp("constants", node->name(), 9) == 0)
					{
						for (xml_node<> *i = node->first_node(); i; i = i->next_sibling())
						{
							if (strncmp("constant", i->name(), 8) == 0 && i->name_size() == 8)
							{
								for (xml_attribute<> *n = i->first_attribute(); n; n = n->next_attribute())
								{
									if (strncmp("name", n->name(), 4) == 0 && n->name_size() == 4)
									{
										constantsData->attributes[QLatin1String(n->value())] = QLatin1String(i->value());
									}
									else
									{
										qWarning() << "GMX Serializer: Unknown constant attribute:" << n->name();
										return 0;
									}
								}
							}
							else
							{
								qWarning() << "GMX Serializer: Unknown constant type:" << i->name();
								return 0;
							}
						}
					}
				}
				else if (node->name_size() == 5)
				{
					if (strncmp("paths", node->name(), 5) == 0)
					{
						addResource(group[Path], node, projectManager->getType("gmpath"),
									"path", QStringLiteral(".path.gmx"));
					}
					else if (strncmp("fonts", node->name(), 5) == 0)
					{
						addResource(group[Font], node, projectManager->getType("fontgroup"),
									"font", QStringLiteral(".font.gmx"));
					}
					else if (strncmp("rooms", node->name(), 5) == 0)
					{
						addResource(group[Room], node, projectManager->getType("gmroom"),
									"room", QStringLiteral(".room.gmx"));
					}
				}
				else if (node->name_size() == 13 && strncmp("NewExtensions", node->name(), 13) == 0)
				{
					addExtension(group[Extension], node);
				}
				else if (node->name_size() == 6 && strncmp("sounds", node->name(), 6) == 0)
				{
					addResource(group[Sound], node, projectManager->getType("audio"),
								"sound", QStringLiteral(".sound.gmx"));
				}
				else if (node->name_size() == 11 && strncmp("backgrounds", node->name(), 11) == 0)
				{
					addBackground(group[Background], node);
				}
				else if (node->name_size() == 4 && strncmp("help", node->name(), 4) == 0)
				{
					count = 0;
					xml_node<> *i;
					for (i = node->first_node(); i; i = i->next_sibling())
					{
						++count;
					}
					if (count > 1)
					{
						qWarning() << "GMX Serializer: Too many help files.";
						return 0;
					}
					i = node->first_node();
					if (strncmp("rtf", i->name(), 3) == 0 && i->name_size() == 3)
					{
						infoResource->location = item->directory()+i->value();
					}
				}
				else if (node->name_size() == 13 && strncmp("TutorialState", node->name(), 13) == 0)
				{
					for (xml_node<> *i = node->first_node(); i; i = i->next_sibling())
					{
						if (strncmp("IsTutorial", i->name(), 10) == 0 && i->name_size() == 10)
						{
							projectData->attributes[QLatin1String("tutorial")] = QLatin1String(i->value());
						}
						else if (strncmp("TutorialName", i->name(), 12) == 0 && i->name_size() == 12)
						{
							projectData->attributes[QLatin1String("tutorial_name")] = QLatin1String(i->value());
						}
						else if (strncmp("TutorialPage", i->name(), 12) == 0 && i->name_size() == 12)
						{
							projectData->attributes[QLatin1String("tutorial_index")] = QLatin1String(i->value());
						}
						else
						{
							qWarning() << "GMX Serializer: Unknown tutorial type:" << i->name();
							return 0;
						}
					}
				}
				else
				{
					qWarning() << "GMX Serializer: assets: Unknown child: " << node->name();
					return false;
				}
				progressBar->setValue(progressBar->value()+1);
			}
			file.close();

			String cacheName;
			Set<String> cached;
			QString directory = item->directory();
			for (Pair<String, Resource*> i : roomMap)
			{
				SerialResource *serialResource = new SerialResource;
				i.second->serialData->children["object_cache"] = serialResource;
				i.second->serialData->children["background_cache"] = serialResource;

				//if (~item->settings & IsPreloaded)
				{
					QFile room(directory+i.second->location);
					room.open(QFile::ReadOnly);
					data = room.readAll();
					document.parse<0>(&data.data()[0]);

					rootNode = document.first_node("room");

					for (node = rootNode->first_node("background")->first_node(); node; node = node->next_sibling())
					{
						if (strncmp("background", node->name(), 10) && node->name_size() == 10)
						{
							attr = node->first_attribute("name");
							if (attr->value_size() != 0)
							{
								cacheName = String(attr->value(), attr->value_size());
								if (cached.find(cacheName) == cached.end())
								{
									serialResource->resources.push_back( backgroundMap.find(cacheName)->second);
									cached.insert(cacheName);
								}
							}
						}
					}
				}
				cached.clear();
			}
*/
			return true;
		}

		void GMXSerializer::restructure(Model::ResourceProjectItem *item) const
		{

		}

		void GMXSerializer::addSprite(Model::ResourceGroupItem *item, xml_node<> *node,
			const Type *type, QString path, const SerializerOptions &options) const
		{
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("sprite", node->name(), 6) == 0)
				{
					if (node->name()[6] != 's')
					{
						//path.append("/sprites/");
						//path.append(QString::fromUtf8(&node->value()[8], node->value_size()-8));
						//path.append(QStringLiteral(".sprite.gmx"));
						path = QString::fromUtf8(&node->value()[0], node->value_size());
						path.append(".sprite.gmx");
						qDebug() << path;
						Resource *resource = new Resource(type, path, Resource::IsFilename);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, QString(&node->value()[8]));
						item->append(content);

						SerialObject *imageData = new SerialObject;
						resource->serialData = imageData;

						QString filepath = content->root()->directory();
						filepath.append(node->value());

						QVector<QPixmap*> *imagesVector = new QVector<QPixmap*>;
						imagesVector->push_back(new QPixmap(filepath));
						SerialVariant *imagesVariant = new SerialVariant();
						imagesVariant->value.setPixmapVec(imagesVector);

						resource->serialData->children["image"] = imagesVariant;
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								qWarning() << "GMX Serializer: sprite: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: sprite: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: sprite: Unknown child type: " << node->name();
				}
			}
		}

		void GMXSerializer::addBackground(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			for (node = node->first_node(); node; node = node->next_sibling())
			{
				if (strncmp("background", node->name(), 10) == 0)
				{
					if (node->name()[10] != 's')
					{
						Resource *resource = new Resource(0, 0, 0);
						Model::ResourceContentItem *content = new Model::ResourceContentItem(resource, QString(&node->value()[11]));
						item->append(content);

						SerialObject *imageData = new SerialObject;
						resource->serialData = imageData;

						QString filepath = content->root()->directory();
						filepath.append(node->value());

						SerialVariant *imagesVariant = new SerialVariant();
						imagesVariant->value.setPixmap(new QPixmap(filepath));

						resource->serialData->children["image"] = imagesVariant;
					}
					else
					{
						QString name;
						xml_attribute<> *attr = node->first_attribute();
						while(attr != nullptr)
						{
							if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
							{
								//if (ErrorMessageBox::abort(QStringLiteral("GMX Serializer: ")%
								qWarning() << "GMX Serializer: background: Unknown group attribute found.";
							}
							name = attr->value();
							attr = attr->next_attribute();
						}
						if (name.isEmpty())
						{
							qWarning() << "GMX Serializer: background: Group name undefined.";
						}
						Model::ResourceGroupItem *group = new Model::ResourceGroupItem(name);
						item->append(group);
						addBackground(group, node);
					}
				}
				else
				{
					qWarning() << "GMX Serializer: background: Unknown child type: " << node->name();
				}
			}
		}

		// Sprite, Background, Path, Object, Room
		bool GMXSerializer::addResourceM(Model::ResourceGroupItem *item,
			xml_node<> *node, const Type *type, const char *literal,
			const size_t &len, const QString &extension,
			Map<String, Resource*> &map) const
		{
			QString name;
			Resource *resource;
			Model::ResourceGroupItem *group;
			Model::ResourceContentItem *content;
			xml_attribute<> *attr;
			xml_document<> document;
			SerialObject *serialObject;

			Stack<Pair<Model::ResourceGroupItem*, xml_node<>*>> stack;
			stack.push(Pair<Model::ResourceGroupItem*, xml_node<>*>(item, node));

			while (!stack.empty())
			{
				item = stack.top().first;
				node = stack.top().second;
				stack.pop();

				for (node = node->first_node(); node; node = node->next_sibling())
				{
					if (strncmp(literal, node->name(), len) == 0)
					{
						if (node->name()[strlen(literal)] != 's' && node->name_size() == len)
						{
							name = QString::fromUtf8(&node->value()[0], node->value_size());
							resource = new Resource(type, name+extension, Resource::IsFilename);
							name = name.right(len+1);
							content = new Model::ResourceContentItem(resource, name);
							map.insert(Pair<String, Resource*>(String(&node->value()[len+1],
								node->value_size()-len-1), resource));

							serialObject = new SerialObject();
							resource->serialData = serialObject;

							if (literal == (char*)"sprite")
							{
								QString projectDir = QDir::currentPath();
								QFile file(resource->location);
								file.open(QFile::ReadOnly);
								QByteArray data = file.readAll();
								document.parse<0>(&data.data()[0]);

								xml_node<> *sprite = document.first_node("sprite");
								sprite = sprite->first_node("frames");
								sprite = sprite->first_node();

								name = QDir::cleanPath(resource->location);
								QDir::setCurrent(name.left(name.lastIndexOf('/')));
								qDebug() << QDir::currentPath();
								QPixmap *pixmap = new QPixmap(QString::fromUtf8(&sprite->value()[0], sprite->value_size()));

								QVector<QPixmap*> *imagesVector = new QVector<QPixmap*>;
								imagesVector->push_back(pixmap);
								SerialVariant *imagesVariant = new SerialVariant();
								imagesVariant->value.setPixmapVec(imagesVector);
								serialObject->children["images"] = imagesVariant;

								resource->icon = QIcon(pixmap->scaled(16, 16));
								QDir::setCurrent(projectDir);

								serialObject->children["object_cache"] = new SerialResource();
							}
							else if (literal == "object")
							{

							}
							else if (literal == "background")
							{
								QString projectDir = QDir::currentPath();
								QFile file(resource->location);
								file.open(QFile::ReadOnly);
								QByteArray data = file.readAll();
								document.parse<0>(&data.data()[0]);

								xml_node<> *image = document.first_node("background");
								image = image->first_node("data");

								name = QDir::cleanPath(resource->location);
								QDir::setCurrent(name.left(name.lastIndexOf('/')));
								QPixmap *pixmap = new QPixmap(QString::fromUtf8(&image->value()[0], image->value_size()));

								SerialVariant *imagesVariant = new SerialVariant();
								imagesVariant->value.setPixmap(pixmap);
								serialObject->children["image"] = imagesVariant;

								resource->icon = QIcon(pixmap->scaled(16, 16));
								QDir::setCurrent(projectDir);
							}
							else if (literal == "room")
							{

							}
							else if (literal =="path")
							{

							}
							else
							{
								if (QMessageBox::critical(0, "Error", QStringLiteral("GMX Serializer: "
										"Unsupported resource reference literal loading found: ") +
										QString::fromUtf8(literal, len-1),
										QMessageBox::Abort | QMessageBox::Ignore) == QMessageBox::Abort)
									{

									}
							}
							item->append(content);
						}
						else if (node->name_size() == len+1)
						{
							attr = node->first_attribute();
							while(attr != nullptr)
							{
								if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
								{
									if (QMessageBox::critical(0, "Error", QStringLiteral("GMX Serializer: ") +
											QString::fromUtf8(literal, len-1) +
											QStringLiteral(": Unknown group attribute found: ") +
											QString::fromUtf8(attr->name(), attr->name_size()),
											QMessageBox::Abort | QMessageBox::Ignore) == QMessageBox::Abort)
									{
										return false;
									}
								}
								name = attr->value();
								attr = attr->next_attribute();
							}
							if (name.isEmpty())
							{
								if (QMessageBox::critical(0, "Error", QStringLiteral("GMX Serializer: ") +
									QString::fromUtf8(literal, len-1) +
									QStringLiteral(": Required attribute \"name\" not found."),
									QMessageBox::Abort | QMessageBox::Ignore) == QMessageBox::Abort)
								{
									return false;
								}
							}
							group = new Model::ResourceGroupItem(name);
							item->append(group);
							stack.push(Pair<Model::ResourceGroupItem*, xml_node<>*>(group, node));
						}
						else
						{
							if (QMessageBox::critical(0, "Error", QStringLiteral("GMX Serializer: ") +
								QString::fromUtf8(literal, len-1) +
								QStringLiteral(": Unknown node type found: ") +
								QString::fromUtf8(node->name(), node->name_size()),
								QMessageBox::Abort | QMessageBox::Ignore) == QMessageBox::Abort)
							{
								return false;
							}
						}
					}
					else
					{
						if (QMessageBox::critical(0, "Error", QStringLiteral("GMX Serializer: ") +
							QString::fromUtf8(literal, len-1) +
							QStringLiteral(": Unknown node type found: ") +
							QString::fromUtf8(node->name(), node->name_size()),
							QMessageBox::Abort | QMessageBox::Ignore) == QMessageBox::Abort)
						{
							return false;
						}
					}
				}
			}
			return true;
		}

		bool GMXSerializer::addResource(Model::ResourceGroupItem *item,
			xml_node<> *node, const Type *type, const char literal[],
			const QString &extension) const
		{
			size_t position	= (literal != "sound" ? 1 : 2);
			size_t len = strlen(literal);
			QString name;
			Resource *resource;
			Model::ResourceGroupItem *group;
			Model::ResourceContentItem *content;
			xml_attribute<> *attr;

			Stack<Pair<Model::ResourceGroupItem*, xml_node<>*>> stack;
			stack.push(Pair<Model::ResourceGroupItem*, xml_node<>*>(item, node));

			while (!stack.empty())
			{
				item = stack.top().first;
				node = stack.top().second;
				stack.pop();

				for (node = node->first_node(); node; node = node->next_sibling())
				{
					if (strncmp(literal, node->name(), len) == 0)
					{
						if (node->name()[strlen(literal)] != 's' && node->name_size() == len)
						{
							name = QString::fromUtf8(&node->value()[0], node->value_size());
							resource = new Resource(type, name+extension, Resource::IsFilename);
							if (literal == "script")
							{
								content = new Model::ResourceContentItem(resource, name.mid(len+2, name.size()-len-6));
							}
							else if (literal == "shader")
							{
								content = new Model::ResourceContentItem(resource, name.mid(len+2, name.size()-len-9));
								SerialObject *serialData = new SerialObject();
								serialData->attributes.insert(QLatin1String("type"), QLatin1String("GLSL"));
								resource->serialData = serialData;
							}
							else
							{
								content = new Model::ResourceContentItem(resource, name.right(len+position));
							}
							item->append(content);
						}
						else if (node->name_size() == len+1)
						{
							attr = node->first_attribute();
							while(attr != nullptr)
							{
								if (strncmp("name", attr->name(), 4) != 0 && attr->value_size() != 4)
								{
									if (QMessageBox::critical(0, "Error", QStringLiteral("GMX Serializer: ") +
										QString::fromUtf8(literal, len-1) +
										QStringLiteral(": Unknown group attribute found: ") +
										QString::fromUtf8(attr->name(), attr->name_size()),
										QMessageBox::Abort | QMessageBox::Ignore) == QMessageBox::Abort)
									{
										return false;
									}
								}
								name = attr->value();
								attr = attr->next_attribute();
							}
							if (name.isEmpty())
							{
								if (QMessageBox::critical(0, "Error", QStringLiteral("GMX Serializer: ") +
									QString::fromUtf8(literal, len-1) +
									QStringLiteral(": Required attribute \"name\" not found."),
									QMessageBox::Abort | QMessageBox::Ignore) == QMessageBox::Abort)
								{
									return false;
								}
							}
							group = new Model::ResourceGroupItem(name);
							item->append(group);
							stack.push(Pair<Model::ResourceGroupItem*, xml_node<>*>(group, node));
						}
						else
						{
							if (QMessageBox::critical(0, "Error", QStringLiteral("GMX Serializer: ") +
								QString::fromUtf8(literal, len-1) +
								QStringLiteral(": Unknown node type found: ") +
								QString::fromUtf8(node->name(), node->name_size()),
								QMessageBox::Abort | QMessageBox::Ignore) == QMessageBox::Abort)
							{
								return false;
							}
						}
					}
					else
					{
						if (QMessageBox::critical(0, "Error", QStringLiteral("GMX Serializer: ") +
							QString::fromUtf8(literal, len-1) +
							QStringLiteral(": Unknown node type found: ") +
							QString::fromUtf8(node->name(), node->name_size()),
							QMessageBox::Abort | QMessageBox::Ignore) == QMessageBox::Abort)
						{
							return false;
						}
					}
				}
			}
			return true;
		}

		void GMXSerializer::addDatafile(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
		}

		void GMXSerializer::addExtension(Model::ResourceGroupItem *item, xml_node<> *node) const
		{
		}

		void GMXSerializer::createTree(const char *typeName, const char *groupName, xml_document<> *document,
									   Model::ResourceGroupItem *item, xml_node<> *node) const
		{
			String location;
			xml_node<> *group;
			xml_attribute<> *attribute;
			for (int i = 0; i < item->count(); ++i)
			{
				if (item->child(i)->toContentItem() != nullptr)
				{
					if (item->child(i)->toContentItem()->resource->location == 0)
					{
						location = "sprites/";
						location += item->text().toLatin1().data();
					}
					else
					{
						location = item->child(i)->toContentItem()->resource->location.toLatin1().data();
					}
					xml_node<> *resource = document->allocate_node(node_element, typeName, location.c_str());
					node->append_node(resource);
				}
				else
				{
					group = document->allocate_node(node_element, groupName);
					attribute = document->allocate_attribute("name", item->text().toLatin1().data());
					group->append_attribute(attribute);
					node->append_node(group);

					createTree(typeName, groupName, document, item->child(i)->toGroupItem(), group);
				}
			}
		}
	}
}
